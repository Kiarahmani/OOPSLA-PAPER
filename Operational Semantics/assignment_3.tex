\documentclass[10, letterpaper]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
 
\newtheorem{definition}{Definition}\usepackage{bussproofs}
\usepackage{mathtools}
\usepackage{nopageno}
\usepackage{graphicx}
\usepackage{graphicx,caption}
\usepackage{dsfont}
\usepackage{subcaption}
\usepackage[]{algorithm2e}
\usepackage{scalerel}

\begin{document}



\subsection*{Definitions}
$op \in$ OperName \hspace{50 mm} $A := \bar{\eta}$\\
$\psi \in$ Contract  \hspace{54 mm} $vis,so \subseteq A \times A$ \\
$\delta \in$ Operation $::= (op,\psi)$  \hspace{35.5 mm} $E:=(A,vis,so)$ \\
$\eta \in $ Effect $::= (s,i,\delta)$  \hspace{41.5 mm} $Cache := op \mapsto  \bar{\eta}$\\



\vspace{10 mm}
\hspace {-30 mm}[Auxiliary Reduction]
\begin{prooftree} \vspace{-10mm}
	\AxiomC{$E'.vis = E.vis \cup S\times\{\eta\}$} \noLine
	\UnaryInfC {$E'.so = E.vis \cup (E.so^{-1}(\eta')\cup\{\eta'\})\times\{\eta\}$}
	\AxiomC{$\eta = \mathds {F}_{op}(S)$} \noLine
	\UnaryInfC{$\eta' = <\eta_{SessID},\eta_{SeqNo}-1>$} 
              		\BinaryInfC{$(E,S) \xhookrightarrow {op}(E',\eta)$}
     \end{prooftree}


\vspace{10 mm}
\hspace {-30 mm}[Cache Refresh]
\begin{prooftree} \vspace{-10mm}
	\AxiomC {$Cache' = Cache [op \mapsto Cache(op)\cup\{\eta\}]$} \noLine
	\UnaryInfC {$\mathds{S_{DEPS}}(\eta_{\psi},\eta) \subseteq Cache(op)$}\noLine
	\UnaryInfC {$\mathds{T_{DEPS}}(\eta_{\psi},\eta) \subseteq Cache$}
	\AxiomC{$op = \eta_{op}$} \noLine
	\UnaryInfC{$\eta\notin Cache(op)$}\noLine
	\UnaryInfC{$\eta \in E.A$} 
              		\BinaryInfC{$(E,Cache) \xrightarrow {} (E,Cache') $}
     \end{prooftree}




\vspace{10 mm}
\hspace {-30 mm}[Non Blocking Execution]
\begin{prooftree} \vspace{-10mm}
	\AxiomC{$\mathds{TYPE} (op) = non\_blocking$} \noLine
	\UnaryInfC {$(E,Cache(op)) \xhookrightarrow {op}(E',\eta)$}
              		\UnaryInfC{$(E,Cache) \xrightarrow {op} (E',Cache) $}
     \end{prooftree}




\vspace{10 mm}
\hspace {-30 mm}[Blocking Execution]
\begin{prooftree} \vspace{-10mm}
	\AxiomC{$\mathds{TYPE}(op)=blocking$} \noLine
	\AxiomC{$\mathds{WAIT}_{op}(\eta)\subseteq Cache(op)$} \noLine
	\UnaryInfC{$(E,Cache(op)) \xhookrightarrow {op}(E',\eta)$} 
              		\BinaryInfC{$(E,Cache) \xrightarrow {op} (E',Cache)$}
     \end{prooftree}   
\vspace{50 mm}
\hrulefill \\
There are a number of functions used in the semantics: 
\begin{itemize}
\item TYPE function classifies operations into $blocking$ and $non\_blocking$ groups, based on their given contracts. Following is the formal definition: \\
$\mathds{TYPE} (H\xrightarrow{r_1;r_2;...;r_k}T) = $ 
$\left\{\begin{matrix}
 blocking & \text{if } (r_k = so),\\ 
 non\_blocking & \text{otherwise} 
\end{matrix}\right.$

\item WAIT function returns the set of effects waiting for which is necessary before exuting an operation. It just separates cases where we only need to wait for effects in session order, that are in the same transaction. 
$\mathds{WAIT}_{op}(\eta) = $
$\left\{\begin{matrix}
 txso^{-1} (\eta) & \text{if } op_{Tail} = x \xrightarrow{txso}\eta_d,\\ 
so^{-1}(\eta) & \text{otherwise} 
\end{matrix}\right.$



\item DEPS function is the heart of our algorithm, it returns the set of effects that an effect is dependent on, in order to enter a logical cache. \\
$\mathds{S_{DEPS}} (H\xrightarrow{r}T,\eta) = $ 
$\left\{\begin{matrix}
(r_1^{-1}(r_2^{-1}...(r_{k-1}^{-1}(\eta)))) & \text{if } (r = r_1;r_2;...;r_k)\\ 
(r_1(\eta)) & \text{if } (r = r_1^*) 
\end{matrix}\right.$


$\mathds{T_{DEPS}} (\psi,\eta) =  $
$\left\{\begin{matrix}
txnso ^{-1} (\eta)&  \text{if } \psi_{Head} = (x \xrightarrow{txso}\eta_H),\\ 
txnso ^{+1} (\eta) &  \text{if } \psi_{Head} = (\eta_{H} \xrightarrow{txso}x)
\end{matrix}\right.$

%txnso ^{-1} (\eta)






\end{itemize}


















\end{document}