%
%=========================================================================
%
\section{Semantics}
\label{sec:semantics}
In this section we formalize our consistency enforcement algorithm with an
operational semantics, which is also a high-level abstraction of our
tool \tool.
The proposed approach is complete for the specification language defined
in \ref{subsec:spec_lang}
and extends the underlying key-value store to a multi-consistent shim
layer. Here for simplicity reasons we present an operational semantics 
parametrized over a contract with a single prop. However, as we explain
in section \ref{subsec:generalization}, the rules can be easily
generalized to cover multiple consistency levels, each specified by an
arbitrary contract. Therefore, in the rest of this section we will assume a given contract $\psi$ of the
following form:
	\begin{smathpar}
	\begin{array}{lcc}
		\psi = \forall (a,b). a \xrightarrow{R} b  \Rightarrow a
		\xrightarrow{\visZ} b, & \spc & R=r_1;r_2;...;r_k \\
	\end{array}
	\end{smathpar}

The operational semantics is defined via a small-step relation over \emph{execution
states}, which are tuples of the form $\E=(\EffSoup,\visZ ,\soZ)$.
The \emph{effect soup} $\E.\EffSoup$, represents the set of all
effects produced in the system, and  $\E.\visZ$,
$\E.\soZ$ $\subseteq \EffSoup \times \EffSoup$, stand for, respectively the
visibility and session order relations
between such effects. 
We also use the notation $\EffSoup_{(condition)}$
to represent the projection of $\EffSoup$ to a subset
of effects  in $\EffSoup$, that satisfy the specified condition.
The reduction step that will be defined, is of the form
\begin{smathpar}
(\E,\op_{<s,i>}) \;\xrightarrow{\V}\; (\E', \eff),
\end{smathpar}
which can be interpreted as a reduction caused by a replica with a local 
set of effects $\V$, after it executes an operation
$\op$, which is the $i$'th request from the session $s$. 
During this reduction step a new effect $\eff$ is produced and added to
the effect soup, with new relations $\visZ$ and $\soZ$ that are updated
accordingly.


%=================================================
%--------- Definitions to be used in the semanrics
%=================================================
\subsection{Preliminaries}
\label{subsec:prelim}
\input{Sections/core_operational_semantics}


%=================================================
%--------- The operational semantics
%=================================================
\subsection{Core Operational Semantics}

%--- The Figure Containing the Rules
\input{Sections/core_semantics}

%--- Section intro
In this part we present the reduction rules, representing our
consistency preservation approach.
Figure \ref{fig:semantics} presents the set of rules defining the
auxiliary relation ($\hookrightarrow$) and small-step reduction relation 
($\rightarrow$) over executions. The latter relation is parametrized
over a set $V$,
that represents the set of effects that are present at the replica
taking the step. Obviously $V$ must be a subset of the initial effect soup 
of the execution, however, there is no other restrictions,
since we only assume eventual consistency in the underlying store.

%--- The [OPER] rule
Let's now go over the auxiliary reduction rule
\rulelabel{oper},
that represtns the procedure of producing a new effect $\eff$, by witnessing a set
of effects $S$. 
An effect is formally defined as a tuple $\eff=(s,op,v)$, representing the
session and the operation name 
whose execution creates $\eff$, and the value
that the replica returns as the response to that operation.
The rule explains how the execution state changes after producing an
effect at a replica. Specifially, in the new state, the effect soup
$\EffSoup'$ must
now contain the newly created effect $\eff$, and the relations $\visZ'$
and $\soZ'$ must capture the fact that the set $S$ was made
visible to $\eta$, and all effects in the initial state from the same
session, are in session order with $\eff$.


%--- Why there is two different rules for (->) relation
Now we explain the rules for reduction relation $(\xrightarrow{V})$,
namely  \rulelabel{vis exec} and
\rulelabel{non-vis exec}, which represent the execution of operations
under  respectively, a waiting contract and a non-waiting contract. 
The necessaity for introducing two separate  rules, comes from the
inherent differences in the enforcement techniques of
waiting and non-waiting contracts. In waiting contracts, where the last
edge is $\soZ$, we are simply required to make sure that the
specified set of dependency effects, is
present at the replica before executing the operation.
In other words, these contracts only specify
the \emph{minimal} set of effects that must be made visible to an
operation. On the other hand, the non-waiting contracts, that end with a
$\visZ$ edge, by only specifying the \emph{maximal} set of visible
effects, allow the replica to pick \emph{any} subset of its local
effects and make them visible to the operations as long as it does not
violate the contracts' logical formula. In an extreme case, replicas can
always pick the empty set and make it visible to the operations, which
would trivially guarantee the presevation of the contract, since no effect
would satisfy its logical premises.

%--- Explaining the operational rules
The preconditions of both reduction rules, include an auxiliary
reduction, explaining the changes that occur in the execution state $\E$
when an operation is performed. Note that for non-waiting contracts
(i.e. when $\visZ\subseteq r_k$), 
not all effects available at the replica are shown to the operation, but
only a subset of it $V'$ is shown, which is defined to be the  maximally
closed subset of $V$ under $R$.
Moreover, both rules contain
$R_V^{-1}(\eff)\subseteq V$ precondition, which basically guarantees the
preservation of the required consistency level when taking the step. Note
that for non-waiting executions, this is trivially satisfied, since the
subset $V'$, by definition includes
the inverse of relation $R$, and only this subset is made visible to
$\eff$. However, for waiting contracts,conisdering the stepwise
definition of $R_V^{-1}$, this condition requires the presence of
$\soZ^{-1}(\eff)$ at the replica, which can be
interpreted as temporarily \emph{blocking} the operation.







%=================================================
%--------- Theorem on correctness of enforcement
%=================================================
\subsection{Soundness}
\label{subsec:sound}
Here, we present a meta-theoretic property showing that the given contract would never be
violated, if the execution is in a consistent state and takes a reduction
step. We start by defining what we mean by a consistent state of the
execution: 
\input{Sections/subsec_theorems}


%=================================================
%--------- Theorem on maxVis and minWait
%=================================================
\subsection{Optimality}
\label{subsec:opt}
Now we will present two theorems, regarding the optimality of our
approach. Firstly, we show that there
cannot be a larger subset of local effects in a replica to be made
visible to an operation, than what
our reduction rules specify. Next, we will prove the liveness property
of our semantics, which guarantees that all replicas will take a step,
given the proper set of local effects. Considering the eventual delivery of all
updates, which is guaranteed by the underlying store, this theorem
guarantees  that our system would never get permanently stuck. 
\input{Sections/subsec_maximality}
\input{Sections/subsec_minimalwait}


%=================================================
%--------- How it can be generalized for all contracts
%=================================================
\subsection{Generalization}
\label{subsec:generalization}
We finish this section by extendeding our ideas in two dimentions. 
We will first explain how to handle an arbitrary
contract $\psi$ of the following form:  
\begin{smathpar}
\psi = \pi_1 \wedge \pi_2 \wedge ... \wedge \pi_m \qquad \qquad 
\pi_i = \forall (a,b). a \xrightarrow{R_i} b \Rightarrow a
\xrightarrow{\visZ} b
\end{smathpar}
Later, we will
explain how to maintain multiple levels of consistency simultaneously,
each of which is defined for a different operation name. We will assume an arbitrary contract
$\psi_{\op}$ for every user-defined operation $\op$, and explain how to
modify our system model to preserve all of them.

To begin with, as we mentioned earlier, all propositions in our specification language,
either put a maximal (when they are non-waiting) or a minimal (when they
are waiting) bound on the subset of local effects to be made visibe to each
opreation. 
This simply means that when the system is given a conjunction
of propositions, it should define the subset in a way, so it would not violate
\emph{any} of them. 
Therefore, by a few modifications we can extend the system to support
all contracts. Firstly, the single premise $R_V^{-1}(\eta) \subseteq V$
in the reduction step rules should be replaced with the following
conjunction: 
\begin{smathpar}
\bigwedge_{1 \leq i \leq m} (R_i)_V^{-1}\subseteq V
\end{smathpar}
Secondly, the definition of the maximal closed subset of local effects
must also be modified to a subset that is closed under \emph{all} given
relations and finally, care must be taken when deciding which of the
reduction steps must be taken when there
are multiple props: the \nonvisrule should be taken if \emph{all} the
given props are waiting and otherwise \visrule must take place.


\begin{comment} 
% I am not sure if we should include the formal definition here. It is
% unnecessarily complex
\begin{smathpar}
\left \lfloor S \right \rfloor_V = S' \spc \iff \spc S'
\subseteq S \; \wedge \;
\bigwedge(R_i)_V^{-1}(S') \subseteq S' \; \wedge \; 
\not\exists
S''.(\bigwedge ((R_i)_V^{-1}(S''))\subseteq S''\wedge |S''|>|S'|)
\end{smathpar}
\end{comment}


Moreover, for modifying the system to handle multiple contracts
simultaneously, we can
extend the local effect set $V$, to a sequence
of sets $V_{\op_i}$, each maintaning  the consistency level for an
operation type $\op_i$. Now we define the modified form of execution steps as
follow:
\begin{smathpar}
(\E,\op_{<s,i>}) 
    \;\xrightarrow{V_{\op}}\;
  (\E',\eff) 
\end{smathpar}
The local effect set $V$ must also be replaced with $V_{\op_i}$ in the 
premises of the reduction rules, so each operation of type $\op_i$ would
only witness the associated subset for its own consistency requirements.
This abstractly represents our implementation, in the sense that all operations
work only on a specific subset of available effects at any replica. The subset, is
maintained according to the contract assosiated with each operation, and
is guaranteed to preserve the consistency requirements following the
theorems of sections \ref{subsec:sound} and \ref{subsec:opt}. 

