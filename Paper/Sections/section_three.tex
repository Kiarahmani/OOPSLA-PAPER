\newpage
%==========================================================
%--- What programs are and how they are written in our tool
%==========================================================
\section{System Model}
In this section, we first describe our system model including the
notions of distributed applications and replicated data objects,
behavioral properties of eventually consistent data stores and consistency guarantees
over operations. Later, we will formally introduce our specification
language, which helps developers to \emph{specify} their desired consistency
levels. 
%--- The intro the programming model and anomalies
%
\subsection{Replicated Data Stores}
\label{subsec:repl_types}
A data store in our system model, is a collection of \emph{replicas},
each of which stores an instance of a replicated \emph{data object}.
The objects,
which are defined by application developers, contain a \emph{state} that
can be read or modified by application \emph{operations}.
Operations can send requests to replicas to read the current state of the object, or
update it, by producing an \emph{update effect}. 
Effects are then propagated and are guaranteed to reach all replicas
eventually, where they similarly modify the objects' state,
by using an \emph{apply} function, defiened by the developers.

Clients interact
with the store by invoking operations on objects, where a \emph{session} is
the sequence of operations invoked by a particular client. Consequently,
operations
(and the update effects of them) can be uniquely identified, by
their invoking \emph{session id} and their \emph{sequence number} in
that particular session. The data store is typically accessed by a large
number of clients concurrently and consequently, and load balancing
regulations of the store, might cause operations to be routed to different replicas,
even if they are from the same session.

Figure \ref{fig:comment_app}(left) shows how such a  







% one paragraph explaining the given code


% one paragraph exaplining an RMW anomaly and explaining how users can
% just declare what they want



\input {Figures/fig_simple_haskell}


\newpage
%
%--- The introduction of the spec language 
%
\subsection{Specification Language}
\label{subsec:spec_lang}












%==========================================================
\newpage














\begin{comment}
Following is the formal syntax of specification language in our system:
\input{Sections/syntax}
\\ The language is general enough to cover all  the known consistency
levels in the context:
\input{Figures/fig_contract_examples}
\\ Specifications written in our language, can be visualized by simple
graphs. For example, \texttt{(MR)} guarantee from the above figure can
be represented as:
\input{Figures/fig_contract_visualize}
\end{comment}
