\section{Formalization}
In this section we first present our specification language and then
introduce the opeational semantics of our tool. The operational semantics of our tool is presented in two different sets. First set of rules, presents the core of our algorithm and we use it to present the proofs of correctness and optimality. 
\subsection{Specification Language}
Following is the formal syntax of contract language in our system:
\input{syntax}
\\ The language is general enough to cover all  the known consistency
levels in the context:
\input{fig_contract_examples}
\\ Contracts written in our language, can be visualized by simple graphs. For example, \texttt{(MR)} contract from the above figure can be represented as:

\input{fig_contract_visualize}

\newpage
\subsection{Core Algorithm Operational Semantics}
Here we explain the the core operational semantics of our algorithm, which for simplicity reasons, 
is parametrized over a single contract 
$\psi = \forall (a,b). a \xrightarrow{Q} b  \Rightarrow a \xrightarrow{vis} b$, where $Q=q_1;q_2;q_3$. 
\\Before intorducing the semantics, we define the inverse of the given composition $Q=q_1;q_2;q_3$ according to a given
set of available effects $P$, as a partial function from $\set{\eff}$ to
$\set{\eff}$. The idea is to define the function only if the \emph{necessary information about the relations beetween effects, is present in P}.
\\ $
Q^{-1}_P (S)= q_1^{-1} (q_2^{-1}(q_3^{-1}(S))), \qquad 
if \; (q_3^{-1}(S) \subseteq P)\wedge
(q_2^{-1}(q_3^{-1}(S))  \subseteq P)$
\\Trivially, the above definition is based on the following definition of
the inverse of a clause :\\
$q^{-1}(S) = 
\begin{cases}
\bigcup^{}_{e\in S}. \{\eta|(\eta,e) \in E.q \}, \hspace{8.5 mm} if \;
q\in\{so,vis\} \\ 
r_1^{-1}(S)\cup r_2^{-1}(S), \qquad \spc \qquad if \; q=r_1\cup r_2\\
q^{-1}(S\cup r^{-1}(S)), \qquad \quad \qquad if \; q=r^* \wedge r^{-1}(S) \neq \emptyset \\
\emptyset, \qquad \quad \hspace{20 mm} \qquad if \; q=r^* \wedge r^{-1}(S) = \emptyset
\end{cases}
$
\\ Moreover, based on their intrinsic differences, we divide clauses into two types. 
Type 1 clauses include a $vis$ relation in the last edge and type 2 clauses do not. 
\\$
\mathtt{Type}(q) = 
\begin{cases}
1 \qquad if \; ((q=vis) \vee (q=vis^*) \vee (\exists r\in
\mathtt{relation}(q=r\cup vis) \vee (q=vis\cup r) \\ 
2 \qquad otherwise
\end{cases}
$

\input{core_semantics}
\subsection {Shim Layer Operational Semantics}
In this section we introduce the complete behavior of our multi-consistenct shim layer as a new set of operational semantics. 
The rules are parametrized over a given map of operation names to
contracts, $\Psi :  op
\mapsto \psi $ and we assume each contract is of the form:
$\Psi(op)=\forall (a,b). a \xrightarrow{Q_{op}} \Rightarrow a \xrightarrow{vis} b.$ 
We use $Q_{op}[m]$ notation to refer to the m'th clause in the composition.
We define a pool to be a set of effects and a value that contains all
the effects that arrive to the replica. 
Our shim layer, also maintains a set of k caches (one cache for each
given contract). Each cache is maintained to be the largest
subset of pool that is closed under its
contract.  i.e. $\forall \eff \in \Cache(op). Q_{op}^{-1}(\eff)
\subseteq \Cache(op) $ 
\\We also maintain a level of availability for each effect
according to an operation and the current pool. If the availability of an effect for
$op$ is $x$, it means
that the effect satisfies the suffix of size $x$ of contract $\Psi(op)$.
An effect $\eta$ satisfies a suffix of size $x\geq 1$ of contaract
$\psi=\forall (a,b). a \xrightarrow{q_1;q_2;...;q_n} b$,
written as $ (\eta \models_{\Pool}^{x} \psi )$, if and only if
$(q_{n-(x-1)};...;q_{n} )^{-1}_{\Pool}(\{\eta\}) \subseteq \Pool$. The
initial availability value for all effects is 0, and increases when more
dependent effects arrive. 
\\Following are the formal definitions: 

%
\begin{minipage}{\columnwidth}
\begin{smathpar}
\stretcharraybig
\begin{array}{lclcl}
  \multicolumn{5}{c}{
    {\delta} \in \mathtt{Replicated\; Data\; Type} \spc\spc
    {v} \in \mathtt{Value}\spc\spc
    {op} \in \mathtt{Operation\; Name}
  }\\
  \multicolumn{5}{c}{
    {s} \in \mathtt{Session\; Id} \spc\spc
    {i} \in \mathtt{Effect\; Id} \spc\spc
    {\rho} \in \mathtt{Replica\; Id}
  }\\
  \eff & \in & \mathtt{Effect} & \coloneqq &  (s,i,op,v)\\
   {\Pool} & \in & \mathtt {Pool} & \coloneqq & (v,\set {\eff}) \\
   {\Cache} & \in & \mathtt {Cache} & \coloneqq & op \mapsto (v,\set{\eff})\\
   \Avail & \in & \mathtt {Avail} & \coloneqq & op \mapsto (\eff \mapsto
\{0,1,...,k-1\}) \\
  F_{op} & \in & \mathtt{Op.\,Def.} & \coloneqq & v \rightarrow \eta\\
  \EffSoup & \in & \mathtt{Eff\,Soup}	  & \coloneqq & \set{\eff} \\
  \visZ,\soZ &	\in & \mathtt{Relations} & \coloneqq & \set{(\eff,\eff)} \\
  {\E} 		& \in & \mathtt{Exec\;State}  & \coloneqq & \Exec \\
  \Theta  & \in & \mathtt{Store}      & \coloneqq & \rho \mapsto
  (\Pool, {\Cache}, \Avail) \\
  {\sigma} 	& \in & \mathtt{Session} 					 	& \coloneqq & \cdot \ALT op::\sigma \\
  \Sigma 		& \in & \mathtt{Session\;Soup}   	 	& \coloneqq &
        \langle s, i, \sigma \rangle \pll \Sigma \ALT \emptyset \\
\end{array}
\end{smathpar}
\end{minipage}
%
\begin{smathpar}
\begin{array}{c}
\ssn(s,\_,\_,\_) = s \spc\spc
\id(\_,j,\_,\_) = j \spc\spc
\oper(\_,\_,op,\_) = op \spc\spc
\rval(\_,\_,\_,n) = n\\
\end{array}
\end{smathpar}






\input{semantics}


