\section{Motivation}
\label {sec:motiv}
\subsection{Replicated Data Types in ECDS }
\input {Figures/fig_simple_haskell}

%intro
To provide further motivation, consider a highly available (low
latency) application for managing comments on posts in 
a photo sharing web site.  Fig.~\ref{subfig:comment_code}
presents a simple Haskell implementation of such an application
cognizant of our system model.  
%impl

In the implementation,
\effectC{} and \stateC{} strings are respectively defined as the text of a single comment, and 
the concatentation of all visible comments associated
with a post.
A new \effectC{} is generated every time a user wants to
comment on a post by calling the \writeC{} function, and a \readC{}
call simply returns the \stateC{} of the object at the serving
replica.
The \applyC{} function, simply returns the updated state of the replica,
which is a concatination of the old state and a given effect.
For perspicuity, we omit any
conflict resolution strategy in the code; however, developers (using
roll-backs, etc) can design the \applyC{} function to resolve
conflicting concurrent updates as they desire.

%explaining the figure and how users interact with the system
An example of how users interact with this application is presented
in Fig. \ref{subfig:example_exec}, where Alice and Bob are
invoking operations on an object (here, a photo of Alice in Chicago), and the 
chronological order of events is given in black circles.
At time \ding{182}, Bob
writes a comment, which is routed to replica \replO{1}, whose
effect is then propagated and delivered to replica \replO{2} at \ding{183};
where Alice's first read operation is routed to at \ding{184}. 
Alice and Bob then keep talking
through more read and write events, while updates are propagated between
the two replica.

%explain the anomaly possible in this setting
As mentioned before, lost-updates, is a well known  undesirable behavior admitted
by ECDS. 
An example of sych anomaly can occure here if at time 
time \ding{187}, Bob is temporarily
disconnected from both replicas in the figure, and his read operation
is routed to another replica that has not yet received any updates from
\replO{1} or \replO{2}. Consequently,
Bob cannot see his first comment and would retry submitting it,
assuming the first time it was failed.

%
\subsection{Ad-hoc Anomaly Prevention}
A known technique to prevent the above anomaly, 
is to tag each effect using a unique identifier  as mentioned in
Sec.~\ref{sec:sys_model}. Using these tags, replicas will be able to
track all locally available effects, and temporarily \emph{block}
operations, until all the preceding effects from the same session 
arrive at the replica. For example, the replica \replO{3} that receives Bob's read
in the example scenario, can simply postpone its execution until all
dependencies arrive.

In order to reduce the overhead of tracking dependencies per
operation, the above idea is further realized using another technique
called \emph{filteration}, which is based on separating the
locally available effects at each replica that have not been applied to
the state yet and those who have. By this separation, in the
above example each replica can
maintain a \emph{safe environment} for operations (e.g. using a soft-state
cache), that contains an effect only if it also contains all the
previous effects from the same session. This way, an operation 
can proceed, when the effect of the very exact previous operation from
the same session is already
applied to the state (which transitively yields the presence of all
dependencies).

We present a new version of our running example
in appendix~\ref{appendix:app}, which is modified to
tolerate the lost-update anomaly by implementing the blocking mechanism
in the \readC{} function and the filteration in the \applyC{} function
as explained above. Unfortunately, these modifications require fundamental and pervasive
changes to the original code including almost all type and function
definitions.  
Additionally, the changes are heavily tangled with application logic, 
complicating reasoning and hampering correctness arguments.

A major drawback of this approach in
stores that do not admit metadata queries (e.g. Cassandra), 
is the \emph{lost histories}\cite{bolton} problem. To face this problem,
for each new session joining, the replicas must perforom a table
alteration at the data store level, to accomodate the data on the newly
joined session.  This  requires strong synchronization of
replicas, degrading application performance and availability.
Moreover, to make the matter worse, new anomalies are constantly
found
%\footnote{In the running example assume Chris gets
%connected to a replica \replO{4}, that only contains Bob's first write.
%Now Chris sees a photo with only one comment "Me too!"} 
in the
systems after the design phase, which require non-trivial, further polluting,  ad-hoc solutions
that leave the old implementation obsolete.









%
%--- What is our alternative approach
%
\subsection{An Alternative}
\input{Figures/fig_syncope_outline}
We now present our generic consistency management tool. 
\tool allows developers to define a consistency level for each
operation \emph{a priory}, and rely on the runtime system for its
satisfaction. Our approach is consisted of generalized blocking and
filteration mechanisms, which admits arbitrary user-defined dependence
relations for each operation and  maintaines a multi-consistent
\emph{shim layer} on top of each ECDS replica. 

The \tool shim layer maintains
multiple safe environments ($E_1,E_2,...$) by periodic (or on-demand) 
reads from the underlying ECDS database, and adding effects to each
environment, only if its dependencies have already been added
(Fig.~\ref{fig:syncope_outline}). 
\tool realizes this idea efficiently, using a simple tagging mechanism that
represents effects in an environment by giving them a tag associated
with that environment. Each operation in \tool only witnesses its
associated environement, and is blocked by the runtime system, if the necessary
effects are not in there yet.

Users in our tool can specify arbitrary consistency guarantees in a
language that is seeded with $\soO$ and $\visO$ relations and allows
them to define constraints on read operations, that can be used to
synthesize appropriate filteration and blocking mechanisms.
For example, the following \emph{contract}, eliminates the possibilty of
lost-update anomaly, by establishing the appropriate condition under which an effect
may become visible to $\hat{\eff}$, the effect of the current operation:
\begin{fmathpar}
\begin{array}{lllll}

\psi_1: & \forall a. &  \xrightarrow{\soZ} \hat{\eff} & \Rightarrow
& a
\xrightarrow {\visZ} \hat{\eff}  \\
\end{array}
\end{fmathpar}





















